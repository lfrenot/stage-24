\documentclass[11pt]{article}

\usepackage[style=numeric, natbib]{biblatex}
\usepackage[margin=20ex]{geometry}
\usepackage{amsmath}
\usepackage{array}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{hypdoc}
\usepackage{libertine}
\usepackage{longtable}
\usepackage{newtxmath}
\usepackage{tabularx}
\usepackage{zi4}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{microtype}
\usepackage{balance}
\usepackage{mathtools}
\usepackage{float}
\usepackage{color}

\addbibresource{references.bib}

\newcommand{\leon}[1]{\textcolor{blue}{#1}}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\hypersetup{colorlinks=true, linkcolor=black}

\begin{document}

\title{CFG Patterns: A new tool to formally verify optimisations in Vellvm}

\author{Leon Frenot\\ Supervised by Yannick Zakowski \& Gabriel Radanne}

\date{February 5th, 2024 - July 5th, 2024}

\begin{titlepage}
  \centering
  {\textsc{École normale supérieure de Lyon} \par}
  \vspace{1cm}
  {\Large \textsc{Internship Report}\par}
  \vspace{1.5cm}
  {\huge\bfseries CFG Patterns: A new tool to formally verify optimisations in Vellvm\par}
  \vspace{2cm}
  {\Large\itshape Leon Frenot\par}
  \vfill
  supervised by\par
  Yannick~Zakowski~\&~Gabriel~Radanne\par
  at ENS Lyon
  \vfill

  % Bottom of the page
  {\large February 5th, 2024 - July 5th, 2024\par}
\end{titlepage}


\tableofcontents
\newpage

\hypersetup{colorlinks=true, linkcolor=red}

\begin{abstract}
  \leon{Abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

\indent
\leon{Debut intro: M2, 20 semaines, LIP, CASH. Yannick Zakowski \& Gabriel Radanne. Goal.}\\

\leon{Compilation certifiée AJD}

\paragraph{}
\leon{Importance de la compilation certifiée, et surtout de certifier les optims.}

\paragraph{The Contribution of This Work}
\begin{itemize}
    \item \leon{Design d'un langage de patterns + Implémentation naive d'un matcher}
    \item \leon{Preuve d'un théorème central pour prouver des optims (sur un CFG)}
    \item \leon{Utiliser ce langage pour deux optims + preuves de correction}
\end{itemize}
\paragraph{Premier exemple: CCstP}

\section{Key concepts}
\label{sec:concepts}

\subsection{LLVM and Vellvm}

\leon{llvm (très rapide)}

\leon{vellvm: but, niveaux d'interprétation (préciser celui auquel on se place)}

\begin{itemize}
  \item \leon{denotational proofs, programmes ouverts $\rightarrow$ utilisera OCFG pour open CFG}
  \item \leon{structure en couche, optimisations qui conservent les traces d'interaction}
\end{itemize}

\leon{pourquoi travailler sur vellvm}

\subsection{ITrees}

\leon{utilité, coinduction, structure, mechanisme de preuve}

\section{Le langage de patterns}
\label{sec:lang}

\begin{itemize}
  \item goal of section: define modular set of simple patterns that can capture optimizable subgraphs of an OCFG.
  \item capture: have a function that, given a pattern and an ocfg, returns a/the subgraph(s) corresponding to the pattern's grammar.
\end{itemize}

\subsection{présentation des patterns + utilité}

\leon{schéma pour chaque pattern}

\leon{dire que head et branch sont déja des patterns ``optimizés'' $\rightarrow$ explications dans~\ref{sec:appr}}

\begin{itemize}
  \item Graph: Pattern ocfg
  \item When: $\forall$ {S}, Pattern S $\rightarrow$ (S $\rightarrow$ bool) $\rightarrow$ Pattern S
  \item Head: $\forall$ {S}, Pattern S $\rightarrow$ Pattern (bid * blk * S)
  \item Focus: $\forall$ {S}, Pattern S $\rightarrow$ Pattern (ocfg * S)
  \item Map: $\forall$ {S} {T}, Pattern S $\rightarrow$ (S $\rightarrow$ T) $\rightarrow$ Pattern T
  \item Block: $\forall$ {S}, Pattern S $\rightarrow$ Pattern (bid * blk * S)
  \item Branch: $\forall$ {S}, Pattern S $\rightarrow$ Pattern (bid * blk * S)
\end{itemize}

\subsection{présentation de patterns/optims possibles (non implémentés)}

\leon{trouver optim avec map?}

\section{Cas d'étude: Block Fusion}
\label{sec:case}

\subsection{motivation for Block Fusion}

\begin{itemize}
  \item blocks leftover by other optims
  \item modifies CFG
  \item fairly simple optim
\end{itemize}

\subsection{Block Fusion pattern}

\leon{defis d'interprétation ($\varphi$ \& term), renomage}

\section{Théorème: \texttt{denote\_ocfg\_equiv}}
\label{sec:equiv}

\leon{exemple plus précis d'une preuve par coinduction}

\subsection*{intro}

\subsection{defis}

\leon{présentation des défis que pose le formalisme + le niveau d'interprétation}

\leon{schéma idée de base $\rightarrow$ problèmes noms et phi $\rightarrow$ hypothèses etc.}

\subsection{hypothèses}

\begin{itemize}
  \item hyp principale: \texttt{denote\_ocfg\_equiv\_cond}
  \item hyps sur nTO et nFROM \leon{! Schémas}
  \item \texttt{dom\_renaming}
\end{itemize}

\subsection{lemmes}

\begin{itemize}
  \item \texttt{bk\_phi\_rename\_eutt}
\end{itemize}

\section{implémentation (+ raison pour s'arrèter à naïve (rapide))}

\section{A voir: Approfondissements}
\label{sec:appr}

\subsection{Loop pattern}

\subsection{Optim efficace}

\section*{Conclusion}
\label{sec:ccl}

\end{document}