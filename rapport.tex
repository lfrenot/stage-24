\documentclass[11pt]{article}

\usepackage[style=numeric, natbib]{biblatex}
\usepackage[margin=20ex]{geometry}
\usepackage{amsmath}
\usepackage{array}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{hypdoc}
\usepackage{libertine}
\usepackage{longtable}
\usepackage{newtxmath}
\usepackage{tabularx}
\usepackage{zi4}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{microtype}
\usepackage{balance}
\usepackage{mathtools}
\usepackage{float}
\usepackage{color}
\usepackage{listings,lstlangcoq}
\usepackage{xcolor}
\usepackage[all]{xy}

\lstdefinestyle{customcoq}{
  columns=flexible,
  mathescape=true,
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=Coq,
  morekeywords={Variant, fun, Arguments, Type, cofix},
  % morekeywords={SOCKAPI,ITREE,data_at,data_at_},
  emph={%
    SOCKAPI,ITree,data_at,data_at_
  },
  emphstyle={\bfseries\color{green!40!red!80}},
  showstringspaces=false,
  basicstyle=\small\ttfamily,
  keywordstyle=\bfseries\color{green!20!black},
  commentstyle=\itshape\color{red!40!black},
  identifierstyle=\color{violet!50!black},
  stringstyle=\color{orange},
  escapeinside={<@}{@>}
}
\newcommand{\inlinecoq}[1]{\mbox{\lstinline[style=customcoq,columns=fixed,basewidth=.48em]{#1}}}
\newcommand{\ilc}[1]{\inlinecoq{#1}}

\addbibresource{references.bib}

\newcommand{\leon}[1]{\textcolor{blue}{#1}}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\hypersetup{colorlinks=true, linkcolor=black}

\begin{document}

\title{CFG Patterns: A new tool to formally verify optimisations in Vellvm}

\author{Leon Frenot\\ Supervised by Yannick Zakowski \& Gabriel Radanne}

\date{February 5th, 2024 - July 5th, 2024}

\begin{titlepage}
  \centering
  {\textsc{École normale supérieure de Lyon} \par}
  \vspace{1cm}
  {\Large \textsc{Internship Report}\par}
  \vspace{1.5cm}
  {\huge\bfseries CFG Patterns: A new tool to formally verify optimisations in Vellvm\par}
  \vspace{2cm}
  {\Large\itshape Leon Frenot\par}
  \vfill
  supervised by\par
  Yannick~Zakowski~\&~Gabriel~Radanne\par
  at ENS Lyon
  \vfill

  % Bottom of the page
  {\large February 5th, 2024 - July 5th, 2024\par}
\end{titlepage}

\tableofcontents
\newpage

\hypersetup{colorlinks=true, linkcolor=red}

\begin{abstract}
  \leon{Abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

\indent
\leon{Debut intro: M2, 20 semaines, LIP, CASH. Yannick Zakowski \& Gabriel Radanne. Goal.}\\

\leon{Compilation certifiée AJD}

\paragraph{}
\leon{Importance de la compilation certifiée, et surtout de certifier les optims.}

\paragraph{The Contribution of This Work}
\begin{itemize}
  \item \leon{Design d'un langage de patterns + Implémentation naive d'un matcher}
  \item \leon{Preuve d'un théorème central pour prouver des optims (sur un CFG)}
  \item \leon{Utiliser ce langage pour deux optims + preuves de correction}
\end{itemize}
\paragraph{Premier exemple: CCstP}

\section{Key concepts}
\label{sec:concepts}

\subsection{LLVM and Vellvm}

\leon{llvm (très rapide)}

\leon{vellvm: but, niveaux d'interprétation (préciser celui auquel on se place)}

\begin{itemize}
  \item \leon{denotational proofs, programmes ouverts $\rightarrow$ utilisera OCFG pour open CFG}
  \item \leon{structure en couche, optimisations qui conservent les traces d'interaction}
\end{itemize}

\leon{pourquoi travailler sur vellvm}

\subsection{ITrees}

\leon{utilité, coinduction, structure, mechanisme de preuve}

\section{The pattern language}
\label{sec:lang}

In this section we will:\begin{itemize}
  \item Define a Domain Specific Language that can capture optimizable subgraphs in an OCFG\@.
  \item Introduce a matcher on this language and the corresponding semantics of each constructor.
  \item Present the Coq implementation of the language, matcher and semantics.
\end{itemize}

\subsection{Defining the language}

Our goal is to define a Domain Specific Language that can characterize optimizable subgraphs in an OCFG\@. To represent that language, we define an inductive datatype.

\begin{figure}[h]
  \label{fig:pat}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Inductive Pattern : Type -> Type :=
    | Graph: Pattern ocfg
    | When: forall  {S}, Pattern S -> (S -> bool) -> Pattern S
    | Map: forall  {S} {T}, Pattern S -> (S -> T) -> Pattern T
    | Focus: forall  {S}, Pattern S -> Pattern (ocfg * S)
    | Block: forall  {S}, Pattern S -> Pattern (bid * blk * S)
    | Head: forall  {S}, Pattern S -> Pattern (bid * blk * S)
    | Branch: forall  {S}, Pattern S -> Pattern (bid * blk * S)
  .
  \end{lstlisting}
  \caption{The \ilc{Pattern} datatype}
\end{figure}

Since the goal of a pattern in to capture a subgraph with a certain structure, the \ilc{Pattern} datatype has a type argument, which represents the return type of the pattern.\\
Each constructor adds to the return types of the following constructors, with the base case \ilc{Graph} accepting any graph.

We will now introduce each constructor and their function.

\paragraph{\ilc{Graph}}

The \ilc{Graph} constructor is the ``base'' case that matches any graph. It does not take any extra argument, and returns the graph given as argument.

\paragraph{\ilc{When}}

The \ilc{When} constructor allows adding a boolean condition to a pattern.
It takes a pattern and a corresponding boolean function as argument, and returns what the patterns matched if it fulfils the condition.

\paragraph{\ilc{Map}}

The \ilc{Map} constructor allows mapping a function onto a pattern's return type.
It takes a pattern and a function as argument, and returns the image of the function by what the patterns matched.

\paragraph{\ilc{Focus}}

The \ilc{Focus} constructor matches any subgraph.
It takes a pattern as argument to match against the rest of the graph, and returns the matched subgraph and what the pattern matched.

\paragraph{\ilc{Block}}

The \ilc{Block} constructor matches any single block in the graph.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.

\paragraph{\ilc{Head}}

The \ilc{Head} constructor matches any block of the graph without predecessors.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.\\
Note that this constructor could not be directly implemented as a \ilc{When (Block \_) \_} since it depends on the rest of the graph, which \ilc{When} wouldn't have access to.

\paragraph{\ilc{Branch}}

The \ilc{Branch} constructor matches any block of the graph whose terminator is a conditional jump.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.
This constructor could be implemented as a \ilc{When (Block \_) \_}, but has been implemented directly because \leon{???}.

\subsection*{Pattern example}

With these constructors, we can build patterns that characterize subgraphs.

For example, we want to capture a subgraph for the \ilc{BlockFusion} fusion optimization. That is: fusing two blocks whose execution always follow each other into a single block.\\
We can recognize the applicable subgraphs with the pattern \ilc{When (Block (Head Graph)) BlockFusion\_f}.\\
\ilc{Block} matches any first block, then \ilc{Head} matches a block that has no predecessors (except possibly \ilc{Block}), and finally \ilc{When _ BlockFusion\_f} sets additional conditions on the two blocks for the optimization.
\begin{figure}[h]
  \xymatrix{
    &&&&\\
    &*+[F]\txt{Block\\Any block}\ar[dd]&&\;\ar@{-->}`u[ul] `[ll] [ll]&\\
    *+[F.]\txt{BlockFusion\_f\\Sets conditions on\\the two blocks}\ar@{..>}`u[ur] [ur]\ar@{..>}`d[dr] [dr]&&&\txt{Graph}\\
    &*+[F]\txt{Head\\No predecessors\\once Block is removed}\ar@{-->}`d[dr] `[rr] [rr]&&&\\ 
    &&&
    \save "2,3"."4,5"*[F--]\frm{} \restore
  }
  \caption{The \ilc{BlockFusion} pattern}
\end{figure}

\subsection{Matcher functions}

To use these patterns, we need to define a matcher function. That is, a function that takes a pattern and an OCFG as argument, and returns a subgraph, or each subgraph, that matches that pattern.

We implemented the \ilc{MatchAll} function, which returns all the subgraphs corresponding to a given pattern.

\begin{figure}[H]
  \label{fig:match}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Fixpoint MatchAll {S} (P: Pattern S) (g: ocfg) : list S :=
    match P with
      | Graph => [g]
      | When p f => filter (fun x => f x = true) (MatchAll p g) 
      | Map p f => map f (MatchAll p g)
      | Focus p => flat_map_r (MatchAll p) (focus g)
      | Block p => flat_map_r (MatchAll p) (blocks g)
      | Head p => flat_map_r (MatchAll p) (heads g)
      | Branch p => flat_map_r (MatchAll p) (branches g)
    end.
  \end{lstlisting}
  \caption{The \ilc{MatchAll} function}
\end{figure}

\begin{figure}[h]
  \label{fig:fmapr}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition flat_map_r {A B C} (f : B -> list C) :=
      fix flat_map_r (l : list (A*B)) : list (A*C) :=
        match l with
        | [] => []
        | (a, b)::q => (map (fun c => (a, c)) (f b))++flat_map_r q
    end.
  \end{lstlisting}
  \caption{The \ilc{flat_map_r} function}
\end{figure}

\noindent
With this, we can have a correctness and completeness proof for applying MatchAll to each constructor.

Proving the correctness for \ilc{Graph}, \ilc{When} and \ilc{Map} is immediate thanks to builtin lemmas on \ilc{filter} and \ilc{map}.

The proof mechanism for \ilc{Block}, \ilc{Head} and \ilc{Branch} are similar. We will now detail it for \ilc{Head}.

\ilc{MatchAll} relies on the \ilc{heads} function to match the \ilc{Head} constructor.\\
The goal of that function is to find all the "heads", i.e. blocks without predecessors, in an OCFG.\\
To do that, it folds a \ilc{heads_aux} function over the map. That function calls the \ilc{predecessors} function on each block, and appends the result to the return list if the block doesn't have predecessors.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition heads_aux (G: ocfg) id b acc : list (bid*blk*ocfg) :=
      if is_empty (predecessors id G)
      then (id, b, delete id G)::acc
      else acc.

    Definition heads (G: ocfg): list (bid*blk*ocfg) := map_fold (heads_aux G) [] G.
  \end{lstlisting}
  \caption{The \ilc{heads} function}
  \label{fig:heads_fun}
\end{figure}

With these function, we can define the semantics corresponding to each function. We have to define them first for the auxiliary function for the semantics proof.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Record heads_aux_sem (G0 G G': ocfg) id b := {
      EQ: G' = delete id G0;
      IN: G !! id = Some b;
      PRED: predecessors id G0 = ∅
    }.

    Definition heads_sem (G G':ocfg) (id:bid) b := heads_aux_sem G G G' id b.
  \end{lstlisting}
  \caption{The semantic definition for \ilc{Head/heads}}
  \label{fig:sem_block_def}
\end{figure}

Finally, we can prove the semantics for the auxiliary function, the \ilc{heads} function and \ilc{MatchAll Head}.

\begin{figure}[H]
  \label{fig:block_cor}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition heads_aux_P G0 (s:list (bid*blk*ocfg)) G :=
      forall id b G', (id, b, G') ∈ s IFF heads_aux_sem G0 G G' id b.

    Lemma heads_aux_correct:
      forall G G0,
      heads_aux_P G0 (map_fold (heads_aux G0) [] G) G.

    Lemma heads_correct:
      forall G G' id b,
      (id, b, G') ∈ (heads G) IFF heads_sem G G' id b.

    Theorem Pattern_Head_correct {S}:
      forall (G: ocfg) (P: Pattern S) id b X,
      (id, b, X) ∈ (MatchAll (Head P) G) IFF
      exists G', heads_sem G G' id b /\ X ∈ (MatchAll P G').
  \end{lstlisting}
\end{figure}

\section{Denotation}
\label{sec:deno}

In this section we will informally define an optimization class, show a theorem for proving the correctness of optimizations of that class, and apply this theorem to an implementation of Block Fusion.

\subsection{An optimization class}

Since the goal of the patterns is to identify subgraphs, we want to focus on optimizations that only modify a section of the graph. (As opposed to ones that may modify everything, like constant propagation.)\\
Ideally, we want to be able to replace any subgraph with an equivalent subgraph.

\begin{figure}[h]
  \xymatrix{
    &&&&&&&&\\
    G_2&\approx&G_2'&\implies&*+[F]{G_2}\ar@{-->}`d[dr] `[r] [r]&*+[F]{G}\ar@{-->}`u[ul] `[l] [l]&\approx&*+[F]{G_2'}\ar@{-->}`d[dr] `[r] [r]&*+[F]{G}\ar@{-->}`u[ul] `[l] [l]\\
    &&&&&&&&
  }
\end{figure}
\begin{figure}[h]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem (g1 g2 g2' : ocfg):
  forall from to, ⟦g2⟧bs (from,to) ≈ ⟦g2'⟧bs (from, to) ->
  forall from to, ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ g1⟧bs (from, to).
  \end{lstlisting}
\end{figure}

However, this ideal theorem is not enough. In the case of Block Fusion for example, since we replace two blocs by one, the change in ids means that either we have to enter by different ids, or we have to exit by different ids.\\
There needs to be some renaming. We chose to apply the renaming to \ilc{to} and to \ilc{g1}'s terminators, since that keeps the semantics equivalent.

We define a function \ilc{ocfg_term_rename} which, given a function over ids \ilc{SIG} and a graph \ilc{g}, returns \ilc{g} with \ilc{SIG} applied to each id in its blocks' terminators.\\
This new function gives us the following theorem:
\begin{figure}[h]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem (g1 g2 g2' : ocfg) (σ : bid -> bid):
  forall from to, ⟦g2⟧bs (from,to) ≈ ⟦g2'⟧bs (from, SIG to) ->
  forall from to, ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ ocfg_term_rename σ g1⟧bs (from, SIG to).
  \end{lstlisting}
\end{figure}

However, this still cannot be applied to Block Fusion. Indeed, if we try to start on the second block, the semantics are obliviously different.\\
Similar issues can come from having an incorrect origin block. So we have to introduce two sets of ids \ilc{nTO} and \ilc{nFROM} to set condition on the input and origin ids.\\
\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem (g1 g2 g2' : ocfg) (σ : bid -> bid) (nFROM nTO: gset bid):
  (forall from to, to ∉ nTO -> from ∉ nFROM -> ⟦g2⟧bs (from,to) ≈ ⟦g2'⟧bs (from, SIG to)) ->
  forall from to, to ∉ nTO -> from ∉ nFROM -> ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ ocfg_term_rename σ g1⟧bs (from, SIG to).
  \end{lstlisting}
\end{figure}

Finally, we need some conditions to make sure that:\begin{itemize}
  \item the unions are well-formed,
  \item \ilc{nFROM} and \ilc{nTO} are preserved during the (coinductive) proof,
  \item \ilc{SIG} only changes ids from \ilc{g2} to \ilc{g2'}.
\end{itemize}

These conditions give us the following final theorem:
\begin{figure}[H]
\begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem denote_ocfg_equiv
  (g1 g2 g2' : ocfg) (σ : bid -> bid) (nFROM nTO: gset bid) :
    inputs g2 ∩ inputs g2' ## nFROM -> nFROM ⊆ inputs g2 ∪ inputs g2' ->
    inputs g2' ∖ inputs g2 ⊆ nTO -> nTO ⊆ inputs g2 ∪ inputs g2' -> nTO ## outputs g1 ->
    g1 ## g2 -> ocfg_term_rename σ g1 ## g2' ->
    (forall id, id ∈ inputs g2 -> (σ id) ∈ inputs g2') ->
    (forall id, id ∉ nFROM -> (σ id) = id) ->
    (forall from to, to ∉ nTO -> from ∉ nFROM -> ⟦g2⟧bs (from,to) ≈ ⟦g2'⟧bs (from, SIG to)) ->
    forall from to,
    to ∉ nTO -> from ∉ nFROM ->
    ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ ocfg_term_rename σ g1⟧bs (from, σ to).
  \end{lstlisting}
  \caption{The \ilc{denote_ocfg_equiv} theorem}
\end{figure}

\subsection{motivation for Block Fusion}

In this section, we will define the Block Fusion optimization, describe a corresponding OCFG pattern,
and outline the proof of correctness of the optimization using the pattern.

The Block Fusion optimization consists of picking two blocks $A$ and $B$,
such that $A$ is the only predecessor of $B$ and $B$ is the only successor of $A$,
and replacing them with a single block containing the code of $A$ and $B$.

This optimization is relevant for three main reasons:\begin{itemize}
  \item It is a commonly used optimization, for example to clear blocks created while building SSA form.
  \item It is an optimization that modifies the graph.
  \item It is simple to prove on paper that the optimization is correct.
\end{itemize}

In the previous section, we already gave a pattern for \ilc{BlockFusion}, we will use a slight variation, which allows further composing:\\\ilc{Definition BlockFusion {S} (P: Pattern S) := When (Block (Head P)) BlockFusion_f.}

\subsection{Block Fusion for real actually I swear}

\ilc{BlockFusion_f} has two conditions:\begin{itemize}
  \item the terminator of the first block is an absolute jump to the second block,
  \item the second block does not have phi nodes.
\end{itemize}

The first condition is needed (instead of just checking the successors) because, if there is a conditional jump, evaluating the condition may lead to an error, and so to a difference in semantic after the fusion.\\
The second condition is needed because of the difference in evaluation between phi-nodes and assignment operations.

With this, we can create a \ilc{fusion} function for Block Fusion (\ilc{term_rename} applies \ilc{SIG} to each id in the terminator).

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Definition fusion (σ: bid -> bid) (idA : bid) (A B: blk): blk := {|
  blk_phis       := A.(blk_phis);
  blk_code       := A.(blk_code) ++ B.(blk_code);
  blk_term       := term_rename σ B.(blk_term);
  blk_comments   := fusion_comments A B
|}.
  \end{lstlisting}
  \caption{The \ilc{fusion} function}
\end{figure}

We also define \ilc{SIGfusion}, the renaming function for Block Fusion:

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Definition σfusion idA idB := fun (id: bid) => if decide (id=idA) then idB else id.
  \end{lstlisting}
\end{figure}

With these, we can prove first that \ilc{fusion} is correct, and then that the Block Fusion optimization is correct.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem Denotation_BlockFusion_correct {S} G idA A idB B f to P (X:S):
  let σ := σfusion idA idB in
  let G0 := delete idB (delete idA G) in
  to <> idB ->
  f <> idA ->
  (idA, A, (idB, B, X)) ∈ (MatchAll (BlockFusion P) G) ->
  ⟦ G ⟧bs (f, to) ≈ ⟦ <[idB:=fusion σ idA A B]> (ocfg_term_rename σ G0) ⟧bs (f, σ to).
      \end{lstlisting}
\end{figure}

\section{A voir: Approfondissements}
\label{sec:appr}

\subsection{Loop pattern}

\xymatrix{
  \ar[d]&&&\ar[d]\\
  *+[F]\txt{A}\ar@/^/[d]& & & *+[F]\txt{B}\ar@/^/[d]\\
  *+[F]\txt{B}\ar@/^/[u] \ar@/_/[dr]\ar[d]& & \Rightarrow & *+[F]\txt{A}\ar@/^/[u] \ar@/_/[dr]\ar[d]\\
  &*+[F]\txt{*}\ar@/_/[ul]& & & *+[F]\txt{*}\ar@/_/[ul]
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{*}\ar[d]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[d]&&\Rightarrow&*+[F]\txt{A}\ar@/_/[dr]\ar[d]\\
  &*+[F]\txt{*}\ar@/_/[ul]&&&*+[F]\txt{*}\ar@/_/[ul]
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{A}\ar@/_/[r]\ar[d]&*+[F]\txt{1}\ar@/_/[l]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[d]&*+[F]\txt{2}\ar@/_/[l]&\Rightarrow&*+[F]\txt{A'}\ar@/_/[r]\ar[d]&*+[F]\txt{2}\ar@/_/[l]\\
  &*+[F]\txt{1}\ar@/_/[u]&&&
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{1}\ar[d]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[dd]&*+[F]\txt{2}\ar@/_/[l]&\Rightarrow&*+[F]\txt{A}\ar@/_/[dr]\ar[d]&*+[F]\txt{1}\ar@/_/[l]\\
  &*+[F]\txt{1}\ar@/_/[u]&&*+[F]\txt{2}\ar[d]&*+[F]\txt{2}\ar@/_/[u]\\
  &&&&&
}

\subsection{Other interpretation levels}

\subsection{Optim efficace}

\section*{Conclusion}
\label{sec:ccl}

\end{document}