\documentclass[11pt]{article}

\usepackage[style=numeric, natbib]{biblatex}
\usepackage[margin=20ex]{geometry}
\usepackage{amsmath}
\usepackage{array}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{hypdoc}
\usepackage{libertine}
\usepackage{longtable}
\usepackage{newtxmath}
\usepackage{tabularx}
\usepackage{zi4}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{microtype}
\usepackage{balance}
\usepackage{mathtools}
\usepackage{float}
\usepackage{color}
\usepackage{listings,lstlangcoq}
\usepackage{xcolor}
\usepackage[all]{xy}

\lstdefinestyle{customcoq}{
  columns=flexible,
  mathescape=true,
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=Coq,
  morekeywords={Variant, fun, Arguments, Type, cofix},
  % morekeywords={SOCKAPI,ITREE,data_at,data_at_},
  emph={%
    SOCKAPI,ITree,data_at,data_at_
  },
  emphstyle={\bfseries\color{green!40!red!80}},
  showstringspaces=false,
  basicstyle=\small\ttfamily,
  keywordstyle=\bfseries\color{green!20!black},
  commentstyle=\itshape\color{red!40!black},
  identifierstyle=\color{violet!50!black},
  stringstyle=\color{orange},
  escapeinside={<@}{@>}
}
\newcommand{\inlinecoq}[1]{\mbox{\lstinline[style=customcoq,columns=fixed,basewidth=.48em]{#1}}}
\newcommand{\ilc}[1]{\inlinecoq{#1}}

\addbibresource{references.bib}

\newcommand{\leon}[1]{\textcolor{blue}{#1}}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\hypersetup{colorlinks=true, linkcolor=black}

\begin{document}

\title{CFG Patterns: A new tool to formally verify optimisations in Vellvm}

\author{Leon Frenot\\ Supervised by Yannick Zakowski \& Gabriel Radanne}

\date{February 5th, 2024 - July 5th, 2024}

\begin{titlepage}
  \centering
  {\textsc{École normale supérieure de Lyon} \par}
  \vspace{1cm}
  {\Large \textsc{Internship Report}\par}
  \vspace{1.5cm}
  {\huge\bfseries CFG Patterns: A new tool to formally verify optimisations in Vellvm\par}
  \vspace{2cm}
  {\Large\itshape Leon Frenot\par}
  \vfill
  supervised by\par
  Yannick~Zakowski~\&~Gabriel~Radanne\par
  at ENS Lyon
  \vfill

  % Bottom of the page
  {\large February 5th, 2024 - July 5th, 2024\par}
\end{titlepage}

\tableofcontents
\newpage

\hypersetup{colorlinks=true, linkcolor=red}

\begin{abstract}
  \leon{Abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

\indent
\leon{Debut intro: M2, 20 semaines, LIP, CASH. Yannick Zakowski \& Gabriel Radanne. Goal.}\\

\leon{Compilation certifiée AJD}

\paragraph{}
\leon{Importance de la compilation certifiée, et surtout de certifier les optims.}

\paragraph{The Contribution of This Work}
\begin{itemize}
  \item \leon{Design d'un langage de patterns + Implémentation naive d'un matcher}
  \item \leon{Preuve d'un théorème central pour prouver des optims (sur un CFG)}
  \item \leon{Utiliser ce langage pour deux optims + preuves de correction}
\end{itemize}
\paragraph{Premier exemple: CCstP}

\section{Key concepts}
\label{sec:concepts}

\subsection{LLVM and Vellvm}

\leon{llvm (très rapide)}

\leon{vellvm: but, niveaux d'interprétation (préciser celui auquel on se place)}

\begin{itemize}
  \item \leon{denotational proofs, programmes ouverts $\rightarrow$ utilisera OCFG pour open CFG}
  \item \leon{structure en couche, optimisations qui conservent les traces d'interaction}
\end{itemize}

\leon{pourquoi travailler sur vellvm}

\subsection{ITrees}

\leon{utilité, coinduction, structure, mechanisme de preuve}

\section{The pattern language}
\label{sec:lang}

In this section we will:\begin{itemize}
  \item Define a Domain Specific Language that can capture optimizable subgraphs in an OCFG\@.
  \item Introduce a matcher on this language and the corresponding semantics of each constructor.
  \item Present the Coq implementation of the language, matcher and semantics.
\end{itemize}

\subsection{Defining the language}

Our goal is to define a Domain Specific Language that can characterize optimizable subgraphs in an OCFG\@. To represent that language, we define an inductive datatype.

\begin{figure}[h]
  \label{fig:pat}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Inductive Pattern : Type -> Type :=
    | Graph: Pattern ocfg
    | When: forall  {S}, Pattern S -> (S -> bool) -> Pattern S
    | Map: forall  {S} {T}, Pattern S -> (S -> T) -> Pattern T
    | Focus: forall  {S}, Pattern S -> Pattern (ocfg * S)
    | Block: forall  {S}, Pattern S -> Pattern (bid * blk * S)
    | Head: forall  {S}, Pattern S -> Pattern (bid * blk * S)
    | Branch: forall  {S}, Pattern S -> Pattern (bid * blk * S)
  .
  \end{lstlisting}
  \caption{The \ilc{Pattern} datatype}
\end{figure}

Since the goal of a pattern in to capture a subgraph with a certain structure, the \ilc{Pattern} datatype has a type argument, which represents the return type of the pattern.\\
Each constructor adds to the return types of the following constructors, with the base case \ilc{Graph} accepting any graph.

We will now introduce each constructor and their function.

\paragraph{\ilc{Graph}}

The \ilc{Graph} constructor is the ``base'' case that matches any graph. It does not take any extra argument, and returns the graph given as argument.

\paragraph{\ilc{When}}

The \ilc{When} constructor allows adding a boolean condition to a pattern.
It takes a pattern and a corresponding boolean function as argument, and returns what the patterns matched if it fulfils the condition.

\paragraph{\ilc{Map}}

The \ilc{Map} constructor allows mapping a function onto a pattern's return type.
It takes a pattern and a function as argument, and returns the image of the function by what the patterns matched.

\paragraph{\ilc{Focus}}

The \ilc{Focus} constructor matches any subgraph.
It takes a pattern as argument to match against the rest of the graph, and returns the matched subgraph and what the pattern matched.

\paragraph{\ilc{Block}}

The \ilc{Block} constructor matches any single block in the graph.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.

\paragraph{\ilc{Head}}

The \ilc{Head} constructor matches any block of the graph without predecessors.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.\\
Note that this constructor could not be directly implemented as a \ilc{When (Block \_) \_} since it depends on the rest of the graph, which \ilc{When} wouldn't have access to.

\paragraph{\ilc{Branch}}

The \ilc{Branch} constructor matches any block of the graph whose terminator is a conditional jump.
It takes a pattern as argument to match against the rest of the graph, and returns the matched block and what the pattern matched.
This constructor could be implemented as a \ilc{When (Block \_) \_}, but has been implemented directly because \leon{???}.

\subsection*{Pattern example}

With these constructors, we can build patterns that characterize subgraphs.

For example, we want to capture a subgraph for the \ilc{BlockFusion} fusion optimization. That is: fusing two blocks whose execution always follow each other into a single block.\\
We can recognize the applicable subgraphs with the pattern \ilc{When (Block (Head Graph)) BlockFusion\_f}.\\
\ilc{Block} matches any first block, then \ilc{Head} matches a block that has no predecessors (except possibly \ilc{Block}), and finally \ilc{When _ BlockFusion\_f} sets additional conditions on the two blocks for the optimization.
\begin{figure}[h]
  \xymatrix{
    &&&&\\
    &*+[F]\txt{Block\\Any block}\ar[dd]&&\;\ar@{-->}`u[ul] `[ll] [ll]&\\
    *+[F.]\txt{BlockFusion\_f\\Sets conditions on\\the two blocks}\ar@{..>}`u[ur] [ur]\ar@{..>}`d[dr] [dr]&&&\txt{Graph}\\
    &*+[F]\txt{Head\\No predecessors\\once Block is removed}\ar@{-->}`d[dr] `[rr] [rr]&&&\\ 
    &&&
    \save "2,3"."4,5"*[F--]\frm{} \restore
  }
  \caption{The \ilc{BlockFusion} pattern}
\end{figure}

\subsection{Matcher functions}

To use these patterns, we need to define a matcher function. That is, a function that takes a pattern and an OCFG as argument, and returns a subgraph, or each subgraph, that matches that pattern.

We implemented the \ilc{MatchAll} function, which returns all the subgraphs corresponding to a given pattern.

\begin{figure}[H]
  \label{fig:match}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Fixpoint MatchAll {S} (P: Pattern S) (g: ocfg) : list S :=
    match P with
      | Graph => [g]
      | When p f => filter (fun x => f x = true) (MatchAll p g) 
      | Map p f => map f (MatchAll p g)
      | Focus p => flat_map_r (MatchAll p) (focus g)
      | Block p => flat_map_r (MatchAll p) (blocks g)
      | Head p => flat_map_r (MatchAll p) (heads g)
      | Branch p => flat_map_r (MatchAll p) (branches g)
    end.
  \end{lstlisting}
  \caption{The \ilc{MatchAll} function}
\end{figure}

\begin{figure}[h]
  \label{fig:fmapr}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition flat_map_r {A B C} (f : B -> list C) :=
      fix flat_map_r (l : list (A*B)) : list (A*C) :=
        match l with
        | [] => []
        | (a, b)::q => (map (fun c => (a, c)) (f b))++flat_map_r q
    end.
  \end{lstlisting}
  \caption{The \ilc{flat_map_r} function}
\end{figure}

\noindent
With this, we can have a correctness and completeness proof for applying MatchAll to each constructor.

Proving the correctness for \ilc{Graph}, \ilc{When} and \ilc{Map} is immediate thanks to builtin lemmas on \ilc{filter} and \ilc{map}.

The proof mechanism for \ilc{Block}, \ilc{Head} and \ilc{Branch} are similar. We will now detail it for \ilc{Head}.

\ilc{MatchAll} relies on the \ilc{heads} function to match the \ilc{Head} constructor.\\
The goal of that function is to find all the "heads", i.e. blocks without predecessors, in an OCFG.\\
To do that, it folds a \ilc{heads_aux} function over the map. That function calls the \ilc{predecessors} function on each block, and appends the result to the return list if the block doesn't have predecessors.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition heads_aux (G: ocfg) id b acc : list (bid*blk*ocfg) :=
      if is_empty (predecessors id G)
      then (id, b, delete id G)::acc
      else acc.

    Definition heads (G: ocfg): list (bid*blk*ocfg) := map_fold (heads_aux G) [] G.
  \end{lstlisting}
  \caption{The \ilc{heads} function}
  \label{fig:heads_fun}
\end{figure}

With these function, we can define the semantics corresponding to each function. We have to define them first for the auxiliary function for the semantics proof.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Record heads_aux_sem (G0 G G': ocfg) id b := {
      EQ: G' = delete id G0;
      IN: G !! id = Some b;
      PRED: predecessors id G0 = ∅
    }.

    Definition heads_sem (G G':ocfg) (id:bid) b := heads_aux_sem G G G' id b.
  \end{lstlisting}
  \caption{The semantic definition for \ilc{Head/heads}}
  \label{fig:sem_block_def}
\end{figure}

Finally, we can prove the semantics for the auxiliary function, the \ilc{heads} function and \ilc{MatchAll Head}.

\begin{figure}[H]
  \label{fig:block_cor}
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition heads_aux_P G0 (s:list (bid*blk*ocfg)) G :=
      forall id b G', (id, b, G') ∈ s IFF heads_aux_sem G0 G G' id b.

    Lemma heads_aux_correct:
      forall G G0,
      heads_aux_P G0 (map_fold (heads_aux G0) [] G) G.

    Lemma heads_correct:
      forall G G' id b,
      (id, b, G') ∈ (heads G) IFF heads_sem G G' id b.

    Theorem Pattern_Head_correct {S}:
      forall (G: ocfg) (P: Pattern S) id b X,
      (id, b, X) ∈ (MatchAll (Head P) G) IFF
      exists G', heads_sem G G' id b /\ X ∈ (MatchAll P G').
  \end{lstlisting}
\end{figure}

\section{Cas d'étude: Block Fusion}
\label{sec:case}

In this section, we will define the Block Fusion optimization, describe a corresponding OCFG pattern,
and outline the proof of correctness of the optimization using the pattern.

\subsection{motivation for Block Fusion}

The Block Fusion optimization consists of picking two blocks $A$ and $B$,
such that $A$ is the only predecessor of $B$ and $B$ is the only successor of $A$,
and replacing them with a single block containing the code of $A$ and $B$.

This optimization is relevant for three main reasons:\begin{itemize}
  \item It is a commonly used optimization, usually to clear blocks created by others.
  \item It is an optimization that modifies the graph.
  \item It is simple to prove on paper that the optimization is correct.
\end{itemize}

In the previous section, we already gave a pattern for \ilc{BlockFusion}, we will use a slight variation, which allows further composing:\\\ilc{Definition BlockFusion {S} (P: Pattern S) := When (Block (Head P)) BlockFusion_f.}

\subsection{\leon{preuve de correction} Théorème: \texttt{denote\_ocfg\_equiv}}
\label{sec:equiv}

Before implementing and proving an implementation for Block Fusion, we first established a larger theorem for optimizations that modify the control flow graph.\\
The goal of that theorem is to allow replacing a part of the OCFG with an equivalent subgraph. And it is as follows: \begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
Theorem denote_ocfg_equiv
  (g1 g2 g2' : ocfg) (σ : bid_renaming) (nFROM nTO: gset bid) :
    inputs g2 ∩ inputs g2' ## nFROM -> nFROM ⊆ inputs g2 ∪ inputs g2' ->
    inputs g2' ∖ inputs g2 ⊆ nTO -> nTO ⊆ inputs g2 ∪ inputs g2' -> nTO ## outputs g1 ->
    g1 ## g2 -> ocfg_term_rename σ g1 ## g2' ->
    dom_renaming σ nFROM g2 g2' ->
    denote_ocfg_equiv_cond g2 g2' nFROM nTO σ ->
    forall from to' to,
    to' = σ to ->
    to ∉ nTO -> from ∉ nFROM ->
    ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ ocfg_term_rename σ g1⟧bs (from, to').
  \end{lstlisting}
  \caption{The \ilc{denote_ocfg_equiv} theorem}
\end{figure}

We will now detail this theorem.

\subsubsection{Arguments}

The theorem takes 6 arguments:\begin{itemize}
  \item \ilc{g1}: The part of the graph that doesn't change\footnote{As can be seen in the figure, it does change slightly, we will discuss this later}.
  \item \ilc{g2} and \ilc{g2'}: The part of the graph that gets replaced, and its replacement.
  \item \ilc{SIG}: a \ilc{bid -> bid} function that maps the inputs of g2 over the inputs of g2'.
  \item \ilc{nFROM} and \ilc{nTO}: Sets of block ids from/to which the execution would not be equivalent.
\end{itemize}

\subsubsection{Conclusion}

The conclusion of the theorem is at follows: \begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    forall from to' to,
    to' = σ to ->
    to ∉ nTO -> from ∉ nFROM ->
    ⟦g2 ∪ g1⟧bs (from,to) ≈ ⟦g2' ∪ ocfg_term_rename σ g1⟧bs (from, to').
  \end{lstlisting}
  % \caption{The \ilc{denote_ocfg_equiv} theorem}
\end{figure}

When replacing \ilc{g2} with \ilc{g2'}, a discrepancy in block ids may appear. For example, when doing Block Fusion, we go from entering with one id and exiting with another, to entering and exiting with the same.\\
Because of that, we need to do some renaming in the rest of the graph to keep the same semantics after the optimization.\\
There are two possibilities, either we change the phi-nodes (and block fusion gets the id of the input block), or we change the terminators (and block fusion gets the id of the output block).\\
Since the semantics of terminators is simpler, we decided to do the latter.

\ilc{ocfg_term_rename} then applies \ilc{SIG} to each block id in the terminator of each block of \ilc{g1}.

\subsubsection{\ilc{denote_ocfg_equiv_cond}}

\ilc{denote_ocfg_equiv_cond} is the equivalence condition on \ilc{g2} and \ilc{g2'}. It is straightforward.

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Definition denote_ocfg_equiv_cond
      (g g': ocfg) (nFROM nTO :gset bid) (σ: bid -> bid) :=
        forall origin header,
          header ∉ nTO ->
          origin ∉ nFROM ->
          ⟦g⟧bs (origin, header) ≈ ⟦g'⟧bs (origin, σ header).
  \end{lstlisting}
\end{figure}

\subsubsection{\ilc{dom_renaming}}

\ilc{dom_renaming} is the condition that fixes\; \ilc{SIG}'s domain.\\
It has two conditions:\begin{itemize}
  \item If an id is in \ilc{g2}, \;\ilc{SIG} id is in \ilc{g2'}.
  \item If an id not in \ilc{nFROM}, it is a fixpoint.
\end{itemize}

\begin{figure}[H]
  \begin{lstlisting}[style=customcoq,basicstyle=\small\ttfamily]
    Record dom_renaming (σ : bid_renaming) (nFROM : gset bid) (g g': ocfg) : Prop :=
      {
        in_dom : forall id, id ∈ inputs g -> (σ id) ∈ inputs g';
        out_dom : forall id, id ∉ nFROM -> (σ id) = id
      }.
  \end{lstlisting}
\end{figure}

\subsubsection{Conditions on \ilc{nTO}}

\paragraph{\ilc{inputs g2' ∖ inputs g2 ⊆ nTO}}

% \begin{figure}
%   \xymatrix{
    
%   }
% \end{figure}

If we add a block from \ilc{g2} to \ilc{g2'}, the execution would be different if we enter the graph though that block.

\paragraph{\ilc{nTO ⊆ inputs g2 ∪ inputs g2'}}

If we enter somewhere that is unchanged, the execution doesn't change.

\paragraph{\ilc{nTO \#\# outputs g1}}

When we exit \ilc{g1} into \ilc{g2} or \ilc{g2'}, the execution needs to still be the same.

\subsubsection{Conditions on \ilc{nFROM}}

\paragraph{\ilc{inputs g2 ∩ inputs g2' \#\# nFROM}}

If we come from somewhere that is in both g2 and g2', the execution should be valid.

\paragraph{\ilc{nFROM ⊆ inputs g2 ∪ inputs g2'}}

If we come from somewhere that was not changed, the execution should still be valid.

\section{A voir: Approfondissements}
\label{sec:appr}

\subsection{Loop pattern}

\xymatrix{
  \ar[d]&&&\ar[d]\\
  *+[F]\txt{A}\ar@/^/[d]& & & *+[F]\txt{B}\ar@/^/[d]\\
  *+[F]\txt{B}\ar@/^/[u] \ar@/_/[dr]\ar[d]& & \Rightarrow & *+[F]\txt{A}\ar@/^/[u] \ar@/_/[dr]\ar[d]\\
  &*+[F]\txt{*}\ar@/_/[ul]& & & *+[F]\txt{*}\ar@/_/[ul]
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{*}\ar[d]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[d]&&\Rightarrow&*+[F]\txt{A}\ar@/_/[dr]\ar[d]\\
  &*+[F]\txt{*}\ar@/_/[ul]&&&*+[F]\txt{*}\ar@/_/[ul]
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{A}\ar@/_/[r]\ar[d]&*+[F]\txt{1}\ar@/_/[l]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[d]&*+[F]\txt{2}\ar@/_/[l]&\Rightarrow&*+[F]\txt{A'}\ar@/_/[r]\ar[d]&*+[F]\txt{2}\ar@/_/[l]\\
  &*+[F]\txt{1}\ar@/_/[u]&&&
}

\xymatrix{
  \ar[dd]&&&\ar[d]\\
  &&&*+[F]\txt{1}\ar[d]\\
  *+[F]\txt{A}\ar@/_/[dr]\ar[dd]&*+[F]\txt{2}\ar@/_/[l]&\Rightarrow&*+[F]\txt{A}\ar@/_/[dr]\ar[d]&*+[F]\txt{1}\ar@/_/[l]\\
  &*+[F]\txt{1}\ar@/_/[u]&&*+[F]\txt{2}\ar[d]&*+[F]\txt{2}\ar@/_/[u]\\
  &&&&&
}

\subsection{Other interpretation levels}

\subsection{Optim efficace}

\section*{Conclusion}
\label{sec:ccl}

\end{document}